\chapter{Процедурална обрада података}\label{ch:\thechapter}

Понекад са подацима желимо да урадимо нешто што није могуће или није практично у SQL-у и потребан нам је неки класичнији програмски језик. Овде ћемо прво видети један овакав пример, симулацију уписа, као део пројекта скрепера, а затим ће бити изложено како приступити бази у програмском језику Python и учитати податке који се затим могу обрадити. Python је чест избор за обраду података због његове концизности и квалитетних библиотека чији је циљ управо статистичка обрада и визуелизације. 

Многи други програмски језици се могу повезати на релациону базу података у неколико линија кода користећи одговарајуће библиотеке на сличан начин, те се на овај начин подаци у потпуности раздвајају од програма који их је генерисао. Ово је веома практично и омогућава употребу ових података свима, без обзира на избор алата и без потребе да разумеју процес који их генерише (иако је ово друго пожељно за верификацију). Они се могу учитати у арбитрарно комплексне (или једноставне) поступке обраде, а неки базичнији примери су изложени у овој глави.

\section{Симулације}

Скрепер може симулирати упис у средње школе на основу успеха у основној и података о квотама за сваки смер, и код за то се налази у класи \code{obrada2017.Simulator}\footnote{Овај код се, наравно, може портовати и у пројекат сервера, међутим модел података у скреперу је лакши за употребу у оваквим ситуацијама.}. Конструктор симулатора прима два аргумента: први, типа \code{Simulator.RankingMethod} одређује како се ученици рангирају, а други, \code{Predicate<UcenikW>} одређује за које све ученике се врши упис. Имплементација \code{RankingMethod}-a може дефинисати арбитраран начин за расподелу бодова и приоритета, и тако одговорити на питања као што je \emph{Како би упис изгледао када би систем бодовања био другачији?}, док се предикатом можемо ограничити да уписујемо само ученике са одређеном особином (тј. други аргумент конструктора се користи као филтер). 

Симулација се врши у методи \code{Simulator\#simulate}. Алгоритам је прилично наиван, али за потребе повремене симулације обавља задовољавајућ посао. Користимо помоћну класу \code{UcenikZelja} која се састоји од једне инстанце \code{UcenikW}-a и једне његове жеље (\code{UcenikW.Zelja}). За сваку жељу сваког ученика креирамо по једну инстанцу ове класе и стављамо их у једну листу коју сортирамо помоћу \code{RankingMethod}-а. Тим редом покушавамо да упишемо ученике у жељене смерове. Међутим, проблем настаје ако се за неког ученика жеља која је на његовој листи жеља каснија у заједничкој листи нађе испред неке раније -- у том случају, очекујемо да ученик буде уписан по својој листи жеља, док алгоритам бира заједничку. Ако до таквој случаја дође, када дођемо до погрешно уписане жеље, исписујемо га из погрешног смера и уписујемо у праву, а затим крећемо итерацију кроз заједничку листу испочетка. Асимптотска анализа најгорег случаја није тривијална, међутим пошто су овде у питању реални подаци а не патолошки случајеви просечно време извршавања ће бити значајно краће од најгорег, с обзиром да се не очекује да често долази до корекције када је неопходно ресетовати итератор. %todo naći neki optimalniji algoritam za ovo

Метода \code{Simulator\#verifySimulation} је тест који служи да упореди дату симулацију са стварним подацима за први круг уписа и испише број разлика. У класи \code{obrada2017\allowbreak.DefaultSimulation} је дат \code{RankingMethod} који се користи при упису у средње школе и \code{DefaultSimulation\allowbreak\#defaultSim} метода која симулира први круг уписа са потпуном тачношћу (у односу на званичне податке), што је доказ да је симулатор исправно написан и да су коришћени подаци комплетни.

%todo još neki primeri simulacija?

\section{Интерфејсовање са базом -- пример у Python-у}

Једна од великих предности података који се чувају у релационој бази је универзалност приступа -- сваки озбиљнији програмски језик има библиотеке које знају како да читају податке из њих. У Python-у, користио сам \code{sqlalchemy} са \code{psycopg2} за конектовање на базу и \code{pandas} за учитавање података из базе у \code{DataFrame} којим се може манипулисати.

Ако претпоставимо да се база налази на localhost-у, на уобичајеном порту (5432), да се зове \code{upisdb}, и приступа јој се са корисничким именом \code{user} и лозинком \code{pass}, код који се повезује на базу изгледа овако:
\begin{minted}{python}
import sqlalchemy as sqla
eng = sqla.create_engine\
    ("postgresql+psycopg2://user:pass@localhost:5432/upisdb")
\end{minted}

док би помоћна метода која може да извршава основне врсте упита (селекцију и пројекцију) била:

\begin{minted}{python}
import pandas as pd
def query(cols, table, where="1=1", order="id"):
    return pd.read_sql_query("select " + cols + " from " + table + " where " 
            + where + " order by " + order, eng)
\end{minted}

Наравно, као аргумент \code{read\_sql\_query} функцији се може проследити арбитраран SQL код. Повратна вредност ће бити \code{DataFrame}, тип података из \code{pandas} библиотеке који има бројне помоћне функције, али ако је намера вршити било какве сложеније математичке операције, препоручљиво је претворити податке у \code{numpy} низ методом \code{numpy.array(df)}, где је df променљива типа \code{DataFrame}, јер је обрада низа значајно бржа. За крај, покажимо како изгледа код који исцртава хистограм општег успеха за све три генерације:

\begin{minted}{python}
import matplotlib.pyplot as plt
def plot_histogram():
    uc2015 = query("prosek_ukupno", "ucenici2015", "prosek_ukupno>=2")\
            ['prosek_ukupno'] #treba nam samo ova kolona
            #pandas po difoltu vraća i indeks kao dodatnu kolonu
    uc2016 = query("prosek_ukupno", "ucenici2016", "prosek_ukupno>=2")\
            ['prosek_ukupno']
    uc2017 = query("prosek_ukupno", "ucenici2017", "prosek_ukupno>=2")\
            ['prosek_ukupno']

    plt.hist(uc2015, bins=36, range=(2, 5), histtype='step', density=True, 
            stacked=True, color='blue', linewidth=1.2)
    plt.hist(uc2016, bins=36, range=(2, 5), histtype='step', density=True, 
            stacked=True, color='green', linewidth=1.2)
    plt.hist(uc2017, bins=36, range=(2, 5), histtype='step', density=True, 
            stacked=True, color='red', linewidth=1.2)
    plt.show()
\end{minted}


\begin{figure}[h]
	\caption{Хистограм просека оцена у претходне три године}
	\centering
	\includegraphics[width=0.95\textwidth]{prosekhist}
\end{figure}


Излаз овог кода је дат на слици 6.1. На овом плоту је интересантно приметити \enquote{скок} код просека 3.5 и 4.5, што су границе за виши успех. Али, оно што је још уочљивије је непропорционално велик број ученика чији је општи успех 5.0. Једноставним SQL упитом се добија и њихов конкретан проценат:

\begin{minted}{sql}
select 2017 as generacija, 
    1.0*(select count(*) from ucenici2017 where prosek_ukupno=5) /
        (select count(*) from ucenici2017) as "procenat 5.0" 
union select 2016, 
    1.0*(select count(*) from ucenici2016 where prosek_ukupno=5) /
        (select count(*) from ucenici2016) 
union select 2015, 
    1.0*(select count(*) from ucenici2015 where prosek_ukupno=5) /
        (select count(*) from ucenici2015)
\end{minted}

\begin{tabular}{c|c}
generacija & prosek 5.0 \\ \hline
2017 & 0.15722062603961893241 \\
2016 & 0.16020161166773906915 \\
2015 & 0.15755675480116976695 \\
\end{tabular}

На сличан начин се може доћи и до осталих корисних информација. Визуелизације су често моћан алат који може указати на специфичне детаље које је потребно истражити, а затим је неопходно и математички показати да је интуиција иза њих тачна.

Детаљнија анализа података, иако верујем да може довести до занимљивих и корисних резултата, је ван домена овог рада. Аналогно показаним примерима, могу се конструисати нови (у програмском језику по избору) и на тај начин добити истраживање које спаја области социологије образовања и обраду великих података. Овакав подухват би захтевао разрађен теоријски увод и методологију (за које овде нема места) и био би добар пример у корист рушења ригидних граница између наука; на послетку, крајњи циљ је исти: долажење до нових знања. Ово је тек једна од многих идеја за употребу модерних технолошких и математичких алата у областима које нису везане за природне науке, већ пружају бољи увид у друштво. Мишљења сам да је овај приступ неминован и да ће бити све заступљенији у будућности, пошто употреба рачунара и доступност података све више расте, а управо они нам омогућавају да изведемо закључке помоћу анализе великих узорака или комплетних популација, што раније није било практично.