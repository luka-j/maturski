\chapter{Процедурална обрада података}\label{ch:\thechapter}

Понекад са подацима желимо да урадимо нешто што није могуће или није практично у SQL-у и потребан нам је неки класичнији програмски језик. Овде ћемо прво видети један овакав пример, симулацију уписа, као део пројекта скрепера, а затим ће бити изложено како приступити бази у програмском језику Python и учитати податке који се касније могу обрадити. Python је чест избор за обраду података због његове концизности и квалитетних библиотека чији је циљ управо статистичка обрада и визуелизације.

\section{Симулације}

Скрепер може симулирати упис у средње школе на основу успеха у основној и података о квотама за сваки смер, и код за то се налази у класи \code{obrada2017.Simulator}. Конструктор симулатора прима два аргумента: први, типа \code{Simulator.RankingMethod} одређује како се ученици рангирају, а други, \code{Predicate<UcenikW>} одређује за које све ученике се врши упис. Имплементација \code{RankingMethod}-a може дефинисати арбитраран начин за расподелу бодова и приоритета, и тако одговорити на питања као што je \emph{Како би упис изгледао када би систем бодовања био другачији?}, док се предикатом можемо ограничити да уписујемо само ученике са одређеном особином (тј. други аргумент конструктора се користи као филтер). 

Симулација се врши у методи \code{Simulator\#simulate}. Алгоритам је прилично наиван, али за потребе повремене симулације обавља задовољавајућ посао. Користимо помоћну класу \code{UcenikZelja} која се састоји од једне инстанце \code{UcenikW}-a и једне његове жеље (\code{UcenikW.Zelja}). За сваку жељу сваког ученика креирамо по једну инстанцу ове класе и стављамо их у једну листу коју сортирамо помоћу \code{RankingMethod}-а. Тим редом покушавамо да упишемо ученике у жељене смерове. Међутим, проблем настаје ако се за неког ученика жеља која је на његовој листи жеља каснија у заједничкој листи нађе испред неке раније -- у том случају, очекујемо да ученик буде уписан по својој листи жеља, док алгоритам бира заједничку. Ако до таквој случаја дође, када дођемо до погрешно уписане жеље, исписујемо га из погрешног смера и уписујемо у праву, а затим крећемо итерацију кроз заједничку листу испочетка. Асимптотска анализа најгорег случаја није тривијална, међутим пошто су овде у питању реални подаци а не патолошки случајеви просечно време извршавања ће бити значајно краће од најгорег, с обзиром да се не очекује да често долази до корекције када је неопходно ресетовати итератор. %todo naći neki optimalniji algoritam za ovo

Метода \code{Simulator\#verifySimulation} је тест који служи да упореди дату симулацију са стварним подацима и испише број разлика. У класи \code{obrada2017\allowbreak.DefaultSimulation} је дат \code{RankingMethod} који се користи при упису у средње школе и \code{DefaultSimulation\allowbreak\#defaultSim} метода која симулира први круг уписа са потпуном тачношћу (у односу на званичне податке), што је доказ да је симулатор исправно написан и да су коришћени подаци комплетни.

%todo još neki primeri simulacija?

\section{Интерфејсовање са базом -- пример у Python-у}