\chapter{Непосредна обрада података}\label{ch:\thechapter}

\section{Кроз скрепер (Java)}

Сетимо се да су омотачи који су корисни у случају обраде података дефинисани у оквиру скрепера. Ово значи да ако желимо да их искористимо, код за обраду мора на неки начин укључивати пројекат који садржи скрепер. За сада, код који обрађује податке ће се налазити у истом пројекту, али у засебним паковањима \code{rs.lukaj.upisstats.scraper\allowbreak.obrada} и \code{rs.lukaj.upisstats.scraper\allowbreak.obrada2017}.

\subsection{Извршавање метода за обраду}

Архитектура пројекта дозвољава да било ко ко има приступ коду дефинише своје методе за обраду и изврши их прослеђивањем параметара \code{exec \{назив\_методе\}} при покретању програма, где је \{назив\_методе\} назив методе коју треба извршити. Могуће је проследити више назива метода раздвојених размаком, у ком случају ће оне бити извршене секвенцијално. Методе које се извршавају на овај начин морају бити статичке и не треба да примају аргументе (могуће је, наравно, да оне читају са стандардног улаза).

Само извршавање метода се врши механизмом који смо већ увели у овом раду у одељку \ref{subs:refl}, рефлекцијом. Међутим, потребан је један додатни корак: све класе у којима се налазе методе које је могуће извршити на овај начин треба додати у скуп \code{obrada\allowbreak.Exec\allowbreak\#executableClasses}, ручном модификацијом методе \code{obrada\allowbreak.Exec\allowbreak\#registerExecutables}. Постоје два разлога зашто је овај наизглед сувишан ручни процес неопходан. Прво, не постоји начин да се рефлекцијом добије референца на неки пакет, који у Java свету не представља много више од обичног директоријума. Друго, да бисмо могли да приступимо некој класи рефлективно, она мора бити учитана, а класе се у Java виртуелну машину учитавају тек у оном тренутку кад су неопходне. Пошто се до тренутка рефлективног извршавања методе ниједан део кода из класе не извршава, она за виртуелну машину ефективно не постоји и није могуће приступити њеним члановима.

Када се \code{main} метода позива са првим параметром \code{exec}, она остале параметре прослеђује \code{Exec\#doExec(String...)} методи која пролази кроз све регистроване класе и тражи статичку методу без параметара са тим именом, коју затим покреће.

\subsection{Учитавање података}

Прва ствар коју треба урадити са свеже преузетим подацима је спојити нешто више од 60 хиљада фајлова са подацима о ученицима у један, како би се убрзало свако будуће учитавање. Метода која ово ради се налази у \code{Exec\#merge} и позива се командом \code{exec merge}. Постојеће методе за учитавање података претпостављају да су подаци спојени на овај начин.

Како су омотачи за податке другачији, тако су и методе за њихово учитавање различити. За генерације 2015. и 2016, постоји \code{obrada.UceniciGroupBuilder} који омогућава нешто грануларнију контролу ученика који ће бити учитани, али очекивање је да ће се за учитавање података углавном користити \code{obrada\allowbreak.UceniciGroup\allowbreak\#svi} статичка метода. Излаз ове методе је \code{UceniciGroup}, што је суштински \code{HashSet<UcenikWrapper>}, проширен са неколико корисних метода. За податке из 2017. године, користи се \code{obrada2017\allowbreak.UceniciBase\allowbreak\#svi}.

Ова два начина представљају релативно \enquote{висок} поглед на учитавање података. Могуће је, наравно, приступити и директно подацима, кроз \code{obrada.FileMerger\#loadFromOne} за ученике и основне школе (у новој верзији) и \code{download.Smerovi\#loadFromFile}, што ове методе интерно и користе. Главни изазови при учитавању података су како смањити количину и број читања са диска (пошто оба утичу на брзину) и што ефикасније парсирати текст у корисне податке. Прва ствар је највећим делом решена спајањем свега у неколико фајлова и кодирањем често коришћених фрагмената текста (видети, рецимо \code{download\allowbreak.UcenikUtils\allowbreak.PredmetiDefault}). Што се друге тиче, највећи проблем је у подразумеваној методи за парсирање текста у Javi, \code{String\#split}, која је много моћнија, и самим тим спорија него што је у овом случају потребно (разлика се, наравно, не примети ако се обрађују мање количине података са неколико десетина хиљада сплитова; међутим, постаје значајна како овај број превазилази милионе). \footnote{Овде вреди споменути и \code{java.util.StringTokenizer} који иако званично застерео (\url{https://bugs.java.com/bugdatabase/view_bug.do?bug_id=4418160}), може бити користан у случајевима да је могуће избећи његове багове.} Стога је било неопходно развити мали токенизер у класи \code{utils\allowbreak.StringTokenizer} који се екстензивно употребљава унутар омотача и у овом контексту га треба користити пре него библиотечне методе.

\subsection{Основни примери обраде}

Када су коначно сви подаци и архитектура на месту, време је да се из њих извуку неке корисне информације. Сама анализа података је периферни део овог рада. За извођење било каквих озбиљнијих закључака, потребно је да рад садржи осмишљену методологију и да изврши саму анализу, што би, ако би се додало на већ постојећи материјал, чинило овај рад преобимним. Уместо тога, основни циљ је да се постави темељ, а делови који следе су примери употребе тог темеља на базичним задацима.

Класа \code{exec.Osnove} садржи методе које приказују како доћи до основних особина података. \code{Osnove\#brojUcenika} на стандардни излаз исписује број ученика за који постоје подаци у свакој генерацији. Тако можемо видети да за 2015. имамо податке за 66338 ученика, од укупно 68419 колико их је приступило завршном испиту у јунском року \citep{izvestaj15}, за 2016. 65274 од 68177 \citep{izvestaj16manjine} и за 2017. 66130 од 67673 \citep{izvestaj17manjine}. Није могуће са сигурношћу тврдити из ког разлога фале подаци за мањи број ученика, али претпоставка је да они нису уписали средњу школу у јунском року, стога се њихови подаци нису налазили на сајту за упис у средње школе.

У истој класи се налази помоћна приватна метода \code{Osnove\allowbreak\#prosekSvi\allowbreak(ToDoubleFunction, ToDoubleFunction)} која као аргументе прима два мапера -- први дефинише како се ученик из старог модела (2015. и 2016. година) претвара у double вредност, а други ради идентичну операцију за нови модел. Када се мапер примени, упросечавају се добијене double вредности и резултат се штампа на стандардни излаз. Ово је суштински функционалан приступ програмирању и практичан је када се ради са много података, а велики део стандардних операција је подржан у стандардној библиотеци кроз \code{java\allowbreak.util\allowbreak.Stream} класу. Командама \code{exec prosekOcene} и \code{exec prosekZavrsni} на излаз се штампају просеци оцена и завршних испита по годинама (ове методе су такође дефинисане у класи \code{Osnove} и интерно позивају \code{Osnove\allowbreak\#prosekSvi} методу).

\subsection{Табеле}

Стандардни излаз је само један од начина да се подаци прикажу кориснику. Он је добро решење када постоји мали број података, али постоје случајеви када желимо да добијемо нешто већи и лепо форматиран излаз. У случају да је могуће тај излаз представити табуларно, идеално би било да излаз наше методе за обраду буде Excel (.xlsx) табела. Java не подржава креирање ових табела ниједном од стандардних метода, али постоји више библиотека који тај посао могу да обаве. У овом пројекту се за испис табела користи Apache POI, који сем табела подржава и друге Office formate.

Метода \code{obrada.Spreadsheets\#writeXSSF(File, String[][])} уписује податке из String матрице у прослеђени фајл као .xlsx табелу. У класи \code{obrada.Teritorijalno} налазе се методе које рачунају просеке по окрузима и местима и уписују резултате у табелу. Тако можемо видети да су 2016. највишу просечну оцену (у просеку) имали ученици који су завршили основну школу у нишавском округу, чак 4.328, док не постоји округ чији је просек општег успеха испод 3.94. Када се погледају просечни бројеви бодова на пријемном, може се уочити да су прва два места иста као и код оцена (нишавски 19.18 и пчињски 19.06), али је занимљиво да је у призренском округу, где је просечна оцена трећа највећа, скоро 4.24, просек бодова на завршном испиту убедљиво најгори: свега 9.285 од максималних 30. Ово нужно повлачи питање да ли су оцене адекватно мерило знања на републичком нивоу, и колико (и зашто) је оправдано да оне носе највећи број бодова, за чији одговор је неопходна засебна анализа.

\section{Над базом (SQL)}

Иако концептуално базичнија, обрада података кроз скрепер је често спора, и за извршавање и за куцање. Пошто смо у одељку \ref{sec:4.4} поставили базу података, већину ових ствари можемо урадити у једној линији SQL-a и добити идентичан резултат много брже.

