\chapter{Непосредна обрада података}\label{ch:\thechapter}

\section{Кроз скрепер (Java)}

Сетимо се да су омотачи који су корисни у случају обраде података дефинисани у оквиру скрепера. Ово значи да ако желимо да их искористимо, код за обраду мора на неки начин укључивати пројекат који садржи скрепер. За сада, код који обрађује податке ће се налазити у истом пројекту, али у засебним паковањима \code{rs.lukaj.upisstats.scraper\allowbreak.obrada} и \code{rs.lukaj.upisstats.scraper\allowbreak.obrada2017}.

\subsection{Извршавање метода за обраду}

Архитектура пројекта дозвољава да било ко ко има приступ коду дефинише своје методе за обраду и изврши их прослеђивањем параметара \code{exec \{назив\_методе\}} при покретању програма, где је \{назив\_методе\} назив методе коју треба извршити. Могуће је проследити више назива метода раздвојених размаком, у ком случају ће оне бити извршене секвенцијално. Методе које се извршавају на овај начин морају бити статичке и не треба да примају аргументе (могуће је, наравно, да оне читају са стандардног улаза).

Само извршавање метода се врши механизмом који смо већ увели у овом раду у одељку \ref{subs:refl}, рефлекцијом. Међутим, потребан је један додатни корак: све класе у којима се налазе методе које је могуће извршити на овај начин треба додати у скуп \code{obrada\allowbreak.Exec\allowbreak\#executableClasses}, ручном модификацијом методе \code{obrada\allowbreak.Exec\allowbreak\#registerExecutables}. Постоје два разлога зашто је овај наизглед сувишан ручни процес неопходан. Прво, не постоји начин да се рефлекцијом добије референца на неки пакет, који у Java свету не представља много више од обичног директоријума. Друго, да бисмо могли да приступимо некој класи рефлективно, она мора бити учитана, а класе се у Java виртуелну машину учитавају тек у оном тренутку кад су неопходне. Пошто се до тренутка рефлективног извршавања методе ниједан део кода из класе не извршава, она за виртуелну машину ефективно не постоји и није могуће приступити њеним члановима.

Када се \code{main} метода позива са првим параметром \code{exec}, она остале параметре прослеђује \code{Exec\#doExec(String...)} методи која пролази кроз све регистроване класе и тражи статичку методу без параметара са тим именом, коју затим покреће.

\subsection{Учитавање података}

Прва ствар коју треба урадити са свеже преузетим подацима је спојити нешто више од 60 хиљада фајлова са подацима о ученицима у један, како би се убрзало свако будуће учитавање. Метода која ово ради се налази у \code{Exec\#merge} и позива се командом \code{exec merge}. Постојеће методе за учитавање података претпостављају да су подаци спојени на овај начин.

Како су омотачи за податке другачији, тако су и методе за њихово учитавање различити. За генерације 2015. и 2016, постоји \code{obrada.UceniciGroupBuilder} који омогућава нешто грануларнију контролу ученика који ће бити учитани, али очекивање је да ће се за учитавање података углавном користити \code{obrada\allowbreak.UceniciGroup\allowbreak\#svi} статичка метода. Излаз ове методе је \code{UceniciGroup}, што је суштински \code{HashSet<UcenikWrapper>}, проширен са неколико корисних метода. За податке из 2017. године, користи се \code{obrada2017\allowbreak.UceniciBase\allowbreak\#load}.

Ова два начина представљају релативно \enquote{висок} поглед на учитавање података. Могуће је, наравно, приступити и директно подацима, кроз \code{obrada.FileMerger\#loadFromOne} за ученике и основне школе (у новој верзији) и \code{download.Smerovi\#loadFromFile}, што ове методе интерно и користе. Главни изазови при учитавању података су како смањити количину и број читања са диска (пошто оба утичу на брзину) и што ефикасније парсирати текст у корисне податке. Прва ствар је највећим делом решена спајањем свега у неколико фајлова и кодирањем често коришћених фрагмената (видети, рецимо \code{download\allowbreak.UcenikUtils\allowbreak.PredmetiDefault}). Што се друге тиче, највећи проблем је у подразумеваној методи за парсирање текста у Javi, \code{String\#split}, која је много моћнија, и самим тим спорија него што је у овом случају потребно (разлика се, наравно, не примети ако се обрађују мање количине података са неколико десетина хиљада сплитова; међутим, постаје приметна како овај број превазилази милионе). \footnote{Овде вреди споменути и \code{StringTokenizer} који иако званично застерео (\url{https://bugs.java.com/bugdatabase/view_bug.do?bug_id=4418160}), може бити користан у случајевима да је могуће избећи његове багове.} Стога је било неопходно развити мали токенизер у класи \code{utils\allowbreak.StringTokenizer} који се екстензивно употребљава унутар омотача и у овом контексту га треба користити пре него уграђене методе.

\subsection{Основни примери обраде}

\subsection{Табеле}

\section{Над базом (SQL)}