\chapter{Непосредна обрада података}\label{ch:\thechapter}

\section{Кроз скрепер (Java)}

Сетимо се да су омотачи који су корисни у случају обраде података дефинисани у оквиру скрепера. Ово значи да ако желимо да их искористимо, код за обраду мора на неки начин укључивати пројекат који садржи скрепер. За сада, код који обрађује податке ће се налазити у истом пројекту, али у засебним паковањима \code{rs.lukaj.upisstats.scraper\allowbreak.obrada} и \code{rs.lukaj.upisstats.scraper\allowbreak.obrada2017}.

\subsection{Извршавање метода за обраду}

Архитектура пројекта дозвољава да било ко ко има приступ коду дефинише своје методе за обраду и изврши их прослеђивањем параметара \code{exec \{назив\_методе\}} при покретању програма, где је \{назив\_методе\} назив методе коју треба извршити. Могуће је проследити више назива метода раздвојених размаком, у ком случају ће оне бити извршене секвенцијално. Методе које се извршавају на овај начин морају бити статичке и не треба да примају аргументе (могуће је, наравно, да оне читају са стандардног улаза).

Само извршавање метода се врши рефлекцијом (овај механизам смо већ увели у одељку \ref{subs:refl}). Међутим, потребно је направити и један додатан корак: све класе у којима се налазе методе које је могуће извршити на овај начин треба додати у скуп \code{obrada\allowbreak.Exec\allowbreak\#executableClasses}, ручном изменом методе \code{obrada\allowbreak.Exec\allowbreak\#registerExecutables}. Постоје два разлога зашто је овај наизглед сувишан ручни процес неопходан. Прво, не постоји начин да се рефлекцијом добије референца на неки пакет, који у Java свету не представља много више од обичног директоријума. Друго, да бисмо могли да приступимо некој класи рефлективно, она мора бити учитана, а класе се у Java виртуелну машину учитавају тек у оном тренутку кад су неопходне. Пошто се до тренутка рефлективног извршавања методе ниједан део кода из класе не извршава, она за виртуелну машину ефективно не постоји и није могуће приступити њеним члановима.

Када се \code{main} метода позива са првим параметром \code{exec}, она остале параметре прослеђује \code{Exec\#doExec(String...)} методи која пролази кроз све регистроване класе и тражи статичку методу без параметара са тим именом, коју затим покреће.

\subsection{Учитавање података}

Прва ствар коју треба урадити са свеже преузетим подацима је спојити нешто више од 60 хиљада фајлова са подацима о ученицима у један, како би се убрзало свако будуће учитавање. Метода која ово ради се налази у \code{Exec\#merge} и позива се командом \code{exec merge}. Постојеће методе за учитавање података претпостављају да су подаци спојени на овај начин.

Како су омотачи за податке другачији, тако су и методе за њихово учитавање различити. За генерације 2015. и 2016, постоји \code{obrada.UceniciGroupBuilder} који омогућава нешто грануларнију контролу ученика који ће бити учитани, али очекивање је да ће се за учитавање података углавном користити \code{obrada\allowbreak.UceniciGroup\allowbreak\#svi} статичка метода. Излаз ове методе је \code{UceniciGroup}, што је суштински \code{HashSet<UcenikWrapper>}, проширен са неколико корисних метода. За податке из 2017. године, користи се \code{obrada2017\allowbreak.UceniciBase\allowbreak\#svi}.

Ова два начина представљају релативно \enquote{висок} поглед на учитавање података. Могуће је, наравно, приступити и директно подацима, кроз \code{obrada.FileMerger\#loadFromOne} за ученике и основне школе (у новој верзији) и \code{download.Smerovi\#loadFromFile}, што ове методе интерно и користе. Главни изазови при учитавању података су како смањити количину и број читања са диска (пошто оба утичу на брзину) и што ефикасније парсирати текст у корисне податке. Прва ствар је највећим делом решена спајањем свега у неколико фајлова и кодирањем често коришћених фрагмената текста (видети, рецимо \code{download\allowbreak.UcenikUtils\allowbreak.PredmetiDefault}). Што се друге тиче, највећи проблем је у подразумеваној методи за парсирање текста у Javi, \code{String\#split}, која је много моћнија, и самим тим спорија него што је у овом случају потребно (разлика се, наравно, не примети ако се обрађују мање количине података са неколико десетина хиљада сплитова; међутим, постаје значајна како овај број превазилази милионе). \footnote{Овде вреди споменути и \code{java.util.StringTokenizer} који иако званично застерео (\url{https://bugs.java.com/bugdatabase/view_bug.do?bug_id=4418160}), може бити користан у случајевима да је могуће избећи његове багове.} Стога је било неопходно развити мали токенизер у класи \code{utils\allowbreak.StringTokenizer} који се екстензивно употребљава унутар омотача и у овом контексту га треба користити пре него библиотечне методе.

\subsection{Основни примери обраде}\label{subs:osn_obrada}

Када су коначно сви подаци и архитектура на месту, време је да се из њих извуку неке корисне информације. Сама анализа података је периферни део овог рада. За извођење било каквих озбиљнијих закључака, потребно је да рад садржи осмишљену методологију и да изврши саму анализу, што би, ако би се додало на већ постојећи материјал, чинило овај рад преобимним. Уместо тога, основни циљ је да се постави темељ, а делови који следе су примери употребе тог темеља на базичним задацима.

Класа \code{exec.Osnove} садржи методе које приказују како доћи до основних особина података. \code{Osnove\#brojUcenika} на стандардни излаз исписује број ученика за који постоје подаци у свакој генерацији. Тако можемо видети да за 2015. имамо податке за 66338 ученика, од укупно 68419 колико их је приступило завршном испиту у јунском року \citep{izvestaj15}, за 2016. 65274 од 68177 \citep{izvestaj16manjine} и за 2017. 66130 од 67673 \citep{izvestaj17manjine}. Није могуће са сигурношћу тврдити из ког разлога фале подаци за мањи број ученика, али претпоставка је да они нису уписали средњу школу у јунском року, стога се њихови подаци нису налазили на сајту за упис у средње школе. Сви прикупљени и изведени подаци посматрају овај узорак као комплетну популацију, сем ако није другачије назначено (нпр. префиксом \code{svi\_} или суфиксом \code{real} у називима колона у бази података за податке који се односе на основне школе 2016. и 2017. године).

У истој класи се налази помоћна приватна метода \code{Osnove\allowbreak\#prosekSvi\allowbreak(ToDoubleFunction, ToDoubleFunction)} која као аргументе прима два мапера -- први дефинише како се ученик из старог модела (2015. и 2016. година) претвара у double вредност, а други ради идентичну операцију за нови модел. Када се мапер примени, упросечавају се добијене double вредности и резултат се штампа на стандардни излаз. Ово је суштински функционалан приступ програмирању и практичан је када се ради са много података, а велики део стандардних операција је подржан у стандардној библиотеци кроз \code{java\allowbreak.util\allowbreak.Stream} класу. Ово се види и у самом коду, тако да наредба којом се ово ради (за старе податке, чија метода за извршавање не враћа \code{Stream}) изгледа овако:
\begin{minted}{java}
System.out.println("2016:"+ UceniciGroup.svi().stream() //pretvaramo u Stream
      //za nove podatke, ovaj poziv je suvišan^^^^^^^^^
        .mapToDouble(mapperOld) //mapiramo u double
        .average().orElse(0)); //tražimo prosek
\end{minted}
где се \code{mapperOld} може написати као једноставна ламбда, рецимо за број бодова на завршном
\begin{minted}{java}
uc -> uc.bodoviSaZavrsnog
\end{minted}
Командама \code{exec prosekOcene} и \code{exec prosekZavrsni} на излаз се штампају просеци оцена и завршних испита по годинама (ове методе су такође дефинисане у класи \code{Osnove} и интерно позивају \code{Osnove\allowbreak\#prosekSvi} методу).

\subsection{Табеле}\label{subs:spreadsheets}

Стандардни излаз је само један од начина да се подаци прикажу кориснику. Он је добро решење када постоји мали број података, али постоје случајеви када желимо да добијемо нешто већи и лепо форматиран излаз. У случају да је могуће тај излаз представити табуларно, идеално би било да излаз наше методе за обраду буде Excel (.xlsx) табела. Java не подржава креирање ових табела ниједном од стандардних метода, али постоји више библиотека који тај посао могу да обаве. У овом пројекту се за испис табела користи Apache POI, који сем табела подржава и друге Office formate.

Метода \code{obrada.Spreadsheets\#writeXSSF(File, String[][])} уписује податке из String матрице у прослеђени фајл као .xlsx табелу. У класи \code{obrada.Teritorijalno} налазе се методе које рачунају просеке по окрузима и местима и уписују резултате у табелу. Тако можемо видети да су 2016. највишу просечну оцену (у просеку) имали ученици који су завршили основну школу у нишавском округу, чак 4.328, док не постоји округ чији је просек општег успеха испод 3.94. Када се погледају просечни бројеви бодова на пријемном, може се уочити да су прва два места иста као и код оцена (нишавски 19.18 и пчињски 19.06), али је занимљиво да је у призренском округу, где је просечна оцена трећа највећа, скоро 4.24, просек бодова на завршном испиту убедљиво најгори: свега 9.285 од максималних 30. Ово нужно повлачи питање да ли су оцене адекватно мерило знања на републичком нивоу, и колико (и зашто) је оправдано да оне носе највећи број бодова, за чији одговор је неопходна засебна анализа.

\section{Над базом (SQL)}\label{ch:obradasql}

Иако концептуално базичнија, обрада података кроз скрепер је често спора, и за извршавање и за куцање. Пошто смо у одељку \ref{sec:4.4} поставили базу података, већину ових ствари можемо урадити у пар линија SQL-a и добити идентичан резултат много брже.

Бројеви ученика се могу тривијално добити упитом 
\begin{minted}{sql}
select 2017 as generacija, count(*) from ucenici2017 
union select 2016, count(*) from ucenici2016 
union select 2015, count(*) from ucenici2015;
\end{minted} 
и тако се уверити да се и у бази заиста налази исти број података као и у фајловима. Слично за просеке, једина потребна измена је \code{count(*)} одговарајућом функцијом (нпр. \code{avg(prosek\_ukupno)}). Занимљиво је видети како просек варира између уписаних смерова у односу на подручје рада. Ово се може урадити упитом
\begin{minted}{sql}
select podrucje, avg(prosek_ukupno) as prosek, 
stddev(prosek_ukupno), sum(broj_ucenika) as "učenici"
from smerovi2017 
where broj_ucenika>15 
group by podrucje 
order by prosek desc;
\end{minted}
који даје следећи излаз

\begin{tabular}{c|c|c|c}
podrucje & prosek & stddev & učenici \\ \hline
zdravstvoisocijalnazastita            & 4.73231565859952 & 0.297691336882488 &         5633 \\
gimnazija                             & 4.68680371427543 & 0.253204961077332 &        16181 \\
kulturaumetnostijavnoinformisanje     & 4.24381746031746 & 0.238293789870836 &          420 \\
ekonomijapravoiadministracija         & 4.20735642474531 & 0.348277753423078 &         7785 \\
elektrotehnika                        & 4.13050006726207 & 0.545924967736679 &         6974 \\
hidrometeorologija                    & 4.06727777777778 & 0.261865211299413 &           60 \\
geodezijaigradjevinarstvo             & 3.83675831018518 & 0.384685731216569 &         1592 \\
saobracaj                             & 3.82960525626415 & 0.535880496961179 &         3603 \\
hemijanemetaliigraficarstvo           & 3.82381498697439 &  0.30181393595203 &         2175 \\
trgovinaugostiteljstvoiturizam        & 3.64542551589161 & 0.492473710339965 &         4470 \\
poljoprivredaproizvodnjaipreradahrane & 3.55875164281608 &  0.34933710194616 &         2869 \\
masinstvoiobradametala                & 3.53225656713681 & 0.391168046713721 &         4887 \\
sumarstvoiobradadrveta                & 3.43830385667377 &  0.40098673865853 &          579 \\
geologijarudarstvoimetalurgija        & 3.37249831649832 & 0.350957008831048 &          327 \\
ostaladelatnostlicnihusluga           & 3.36554173630954 & 0.304710464546345 &          679 \\
tekstilstvoikozarstvo                 & 3.28472091825989 & 0.306707049913011 &          710 \\
\end{tabular}

Намеће се питање, обзиром на незанемарљиву разлику у старту, колико су смерови уопште уједначени и да ли се њихове оцене касније могу директно поредити (као што се ради при упису на факултете)? Важније, из ког разлога уопште настаје оволика разлика на тако широкој категоризацији као што је подручје рада? Сличан упит се може извршити за оцене за сваки појединачни предмет, резултате завршног, или неко географско категорисање слично оном у примеру из одељка \ref{subs:spreadsheets}; могућности су практично неограничене.

При писању упита постоји пар специфичности на које треба обратити пажњу. У претходном, у \code{where} клаузули стоји услов који занемарује смерове са мање од 15 уписаних ученика; ово је вештачка граница чија је једина сврха да избаци смерове који ће (највероватније) бити расформирани услед недовољног броја ученика. Овакви смерови често превише утичу коначни резултат и генерално су гори од оних који упишу више ученика (ово се такође може проверити упитом). Треба пазити и на број предмета, који није свуда исти и варира од три (ШООО Обреновац, 8. разред, 2016. година) до петнаест (поједини ученици припадници националних мањина који уче српски као други матерњи језик). Нова варијанта скрепера ово решава на најоптималнији могући начин и правилно узима у обзир све вредности са сајта, али се у старијим подацима могу пронаћи ученици чији је просек мањи од два, јер су на сајту уместо празних оцена стојале нуле. Такође, мора се узети у обзир да оцена из владања може бити и јединица: 2017. године 165 ученика имало је закључену јединицу из владања у барем једном од разреда.

Сем ових објашњивих, постоје и неке неочекиване аномалије: 2016. за ученика са шифром 223492 нису уопште унете оцене (уписан по одлуци ОУК), док у 2017. постоји шест ученика који немају уписане податке о полаганом завршном испиту (182032, 205680, 114339, 120101, 316117, 188860). Упркос обавештењу на сајту које тврди да \emph{Ученик није завршио основну школу, те не може конкурисати за упис у средњу школу}, сви су уписани по одлуци ОУК. Можда још чудније, број бодова за ученика 163700 је испод теоретског минимума, јер нису унете никакве оцене за осми разред (он је уписан у другом кругу, по првој и јединој жељи), а за још шест фале оцене из математике у осмом разреду (шифре 169542, 965611, 199108, 201805, 869154, 247545). Иако је у теорији могуће да овакве грешке настану услед багова у скреперу, у пракси се показало да то није случај, већ су такви подаци преузети са сајта (сви овде наведени примери су и ручно проверени). Ове и сличне ствари само указују на то да систем није савршен и да се дешава да поједини примери делују бесмислено. Стога, најбоље је да се при анализи усвоји дефанзиван приступ и покушају да се формулишу и примене сви неопходни услови, ма колико они здраворазумски звучали.