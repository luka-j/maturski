\chapter{Сервер и база}\label{ch:\thechapter}

\section{Улога сервера}

Основни циљ скрепера је управо скреповање, тј. преузимање података, док је њихова обрада на другом месту. Иако је могуће написати релативно напредне методе за обраду и покренути их користећи интерфејс који главни програм подржава, он и даље има неколико ограничења. Први проблем је учитавање: подаци могу да се учитају или из појединачних фајлова, што је изузетно споро у великим количинама, или из једног спојеног фајла, што може сместити више података у меморију него што је неопходно. Друго, програм је конципиран да ради на једној генерацији у било ком тренутку; иако је могуће учитати податке за више генерација истовремено и оперисати над њима, овај процес би могао бити много лакши. Напослетку, пошто је оригинална замисао да се програм не покреће више од једанпут годишње, перформансе често нису биле приоритет.

Сви ови проблеми се могу решити увођењем релационе базе података.\footnote{Могуће је, наравно, било да се подаци у старту памте у релационој бази, али 2015. када сам започео овај пројекат нисам га тако конципирао. Касније је свакако било неопходно да се напише код за портовање, па није било разлога да се оригинални пројекат модификује.} Прва улога сервера ће бити управо изградња ове базе користећи модел података који скрепер пружа, а затим ћемо показати како се овај сервер може употребити за реализовање сервиса који користе ову базу. Разлог за коришћење комплетног сервера уместо, рецимо, писања метода који би на неки од стандардних начина (нпр. кроз JDBC) оперисали над базом је чињеница да велики број ствари долази уграђено, тако да се избегава директан приступ бази тамо где то није неопходно.

Сервер је писан у Play! Framework-у, који је оригинално део Scala (програмски језик који се компајлира за JVM, делом инспирисан Javom) екосистема, али подржава и Java језик. Уместо Gradle-a користи SBT (видети \url{https://www.scala-sbt.org/1.x/docs/Getting-Started.html}), има уграђен ОРМ (више о томе у одељку 4.3) и има нешто другачију структуру директоријума. С друге стране, и даље је у питању Java код, тако да нису неопходни огромни уводи за његово разумевање. Debug мод се покреће командом \code{./sbt run}, а цео пројекат се компајлира и пакује са \code{./sbt dist}, који креира .zip фајл у директоријуму \code{target/universal/}.



\section{База података}
\vspace*{-7mm}
\emph{За базу података која ће се овде коментарисати, видети додатак \ref{ch:B}.} %ovo je latinično B, kao breza

У бази се чува шест типова ентитета: ученик, смер, основна школа, такмичење, листа жеља и пријемни испит. Са изузетком пријемног испита који су издвојени тек у 2017. години, сви имају три подтипа, за сваку годину прикупљања. Између 2015. и 2016. године постоје мање разлике, док су оне израженије у новијој варијанти, стога има смисла раздвојити их у различите табеле. 

Ентитет ученик садржи оцене за сваки предмет од шестог до осмог разреда (у формату \code{\{име\_предмета\}\allowbreak\{бројразреда\}}), просеке (у формату \code{\{име\_предмета\}\_p}), бројеве бодова као и укупан број бодова, и страни кључ који указује на завршену основну школу и уписани смер. Истоветни подаци о оценама и бодовима се налазе и унутар основних школа и смерова, и они представљају просечне вредности истоветно названих атрибута ученика који су ту школу похађали/тај смер уписали. Уз то, доступни су и основни подаци о свакој основној школи и смеру, као што су место, округ, број ученика, а за смерове и средња школа, подручје рада, квота и трајање. Префикс \code{svi\_} у називима атрибута који се односе на податке из 2017. године означава да се тај податак односи на све ученике, а не само на оне који су уписали средњу школу. Такмичења, пријемни и листа жеља садрже број бодова, страни кључ који упућује на ученика и детаље попут редног броја жеље или нивоа и награде на такмичењу.

Приметићемо да су неки од овде наведених података изведени, тј. да се могу добити директном обрадом осталих података. Иако се то у општем случају сматра лошом праксом, ова база има неколико специфичних особина. Прво, неке ствари би било непрактично рачунати путем SQL-а, нпр. формула за просек оцена није тривијална када се узме у обзир да се број оцена по разреду варира од 7 до 15 међу ученицима, посебно када знамо да неке од ових информација већ постоје на самом сајту. Битније, ова база није променљива.\footnote{У току развоја, ако се примети грешка, може бити потребе да се одређени подаци промене. И у овом случају, након што се грешка исправи, лакше је обрисати све податке за одређену генерацију и затим их поново учитати него писати посебан код који би преправљао податке редом.} Подаци у њој су финални и нема смисла мењати их, већ је једина валидна операција додавање, тако да нема потребе да бринемо о њиховом ажурирању.



\section{Структура сервера}
\vspace*{-7mm}
\emph{За изворни код који ће се овде коментарисати, видети додатак \ref{ch:V}.}

Како не би било непотребног дуплицираног кода, сервер укључује целокупан скрепер као библиотеку. Овај процес је у највећој мери аутоматизован: комплетан код се налази на \url{https://github.com/luq-0/UpisScrapper}, што омогућава коришћење \url{https://jitpack.io} сервиса, који пакује и објављује пројекат као библиотеку. Све што је преостало је њено укључивање у пројекат сервера, у фајлу \code{build.sbt} који се налази у кореном директоријуму (последња линија текста). Надаље можемо користити све јавне методе и поља из скрепера у коду сервера.

Унутар \code{conf/} директоријума се налазе конфигурацијски фајлови. Најважнији део \code{conf/\allowbreak application\allowbreak.conf} фајла су параметри за конектовање на базу -- када податке учитате у сопствену базу, потребно је подесити корисничко име, лозинку и адресу базе у одговарајућим \code{db.default.*} пољима. \code{routes} фајл дефинише руте, тј. одређује која ће се метода позвати за сваку путању. Нпр. ако корисник посети \code{\{адреса\_сервера\}\allowbreak/query\allowbreak?initial=asdf}, позваће се \code{controllers.Index\#query} са аргументом \code{asdf} (за случај да \code{initial} параметар није прослеђен, методи се шаље празан \code{String}).

Унутар \code{conf/evolutions.default} директоријума се налазе еволуције за \code{default} базу. Овај механизам нам омогућава да ажурирамо структуру базе (нпр. да додамо нове табеле сваке године), као и да се крећемо унапред и уназад кроз различите верзије базе. Свака еволуција се састоји из два дела: \code{Ups} који дефинише нове измене и \code{Downs} у којем се налази код за враћање из измењеног у старо стање. Оба дела се састоје из SQL наредби које модификују структуру базе, попут \code{CREATE TABLE}, \code{DROP TABLE} и \code{ALTER TABLE}. Фајлови се извршавају секвенцијално. Први фајл, \code{1.sql}, је аутоматски генерисан.

Програмски код се налази у \code{app/} директоријуму. Пакет \code{controllers} дефинише класе које примају захтеве (од рутера), \code{models} одређују структуру података, а \code{views/} презентују странице кориснику.



\section{Изградња базе}\label{sec:4.4}

\subsection{ОРМ и модел}

Једини SQL код написан за потребе овог пројекта је онај за еволуције, и то не рачунајући прву. Остатак генерише \emph{објектно-релациони мапер} (ОРМ, енгл. object-relational mapper) који класе из објектно-оријентисаног језика као што је Java преводи у SQL табеле и, аналогно, објекте у инстанце ентитета, односно редове у табели. Објектно-оријентисано програмирање није базирано ни на каквом математичком формализму (иако постоје покушаји да се развије рачун који би га описао \citep{abadi2012theory}), док се релационе базе података темеље на релационој алгебри. Ова два система нису потпуно еквивалентна, стога ни мапирање не може бити савршено \citep{barnes2007object}. Међутим, ако се на уму има жељени резултат, могуће је саставити класе које би га генерисале без већих проблема. Подразумевани мапер за Java пројекте писане у Play! Framework-у је Ebean (\url{http://ebean-orm.github.io/}), који се користи и у овом пројекту.

Класе из којих се генеришу табеле налазе се у пакету \code{models}. Све класе које немају годину као суфикс су суперкласе и садрже поља која су заједничка за све ентитете тог типа, без обзира на генерацију и оне носе анотацију \code{@MappedSuperclass} што означава да не
Ученик није завршио основну школу, те не може конкурисати за упис у средњу школу
 постоји табела у физичком моделу за њих. Оне проширују класу \code{com.avaje.ebean.Model} која је \enquote{основа} за све ентитете. Класе које их наслеђују наслеђују њихова поља и имају опцију да додају своја, у случају да су се за ту генерацију прикупљали још неки додатни подаци (ово је посебно изражено код података преузиманих са новог портала, тј. за генерацију која је завршила основну школу 2017. године). Оне су означене анотацијама \code{@Entity} и \code{@Table} са атрибутом \code{name} који означава име табеле у којој се подаци смештају.

Унутар класа, сваки примитивни податак и \code{String} добија своју колону примитивног SQL типа. Ако је поље класа која је уједно и ентитет (носи \code{@Entity} анотацију), креира се колона која ће служити као страни кључ ка табели која је дефинисана датим ентитетом и треба је обележити \code{ManyToOne} или \code{OneToOne} анотацијом. Ако је поље листа ентитета, креира се \emph{one-to-many} веза са ентитетом који ће садржати страни кључ ка овом ентитету. \footnote{Технички, креира се \textit{many} крај на повезаном ентитету, који такође може садржати листу и тако дефинисати \emph{many-to-many} везу. Аутоматско разрешавање овога доводи до креирање нове табеле и често није оптимално, па се у овом пројекту не користи.} \textit{Many} крај може експлицитно дефинисати референцу ка \textit{one} крају тако што ће садржати поље адекватног типа. \textit{One-to-many} и, са друге стране, \emph{many-to-one} везе морају бити обележене адекватним анотацијама над пољима.

Узмимо класу \code{Ucenik2017} као пример. Унутар ње, постоје \code{@ManyToOne} поља за основну школу и уписани смер. (Унутар ова два ентитета не постоји одговарајућа листа, јер нема потребе учитавати и све ученике из базе када се учита школа -- углавном је довољно да се само један крај везе спецификује, а ОРМ ће решити други.) Али, пошто ученици углавном имају више жеља, потребна је листа жеља (типа \code{List<Zelja2017>}, која је обележена са \code{@OneToMany}. Овде експлицитно наводимо и други крај, тако да је потребно код листе жеља експлицитно назначити да је други крај везе заправо поље \code{Zelja2017\#ucenik} користећи \code{mappedBy} атрибут.

ОРМ аутоматски генерише и извршава наредбе за чување, ажурирање и брисање података из базе када се позове \code{Model\#save}, \code{Model\#update} или \code{Model\#delete}. \code{Model\allowbreak.Finder} служи за проналажење одређене инстанце, и у сваком ентитету постоји одговарајуће статичко поље \code{finder} помоћу кога се може приступити садржају базе (еквивалентно \code{SELECT} упитима).

\subsection{Учитавање података, ламбде и рефлекција}\label{subs:refl}

Методе за учитавање података се налазе унутар \code{controllers.Init} класе. И овде постоје две варијанте -- за податке пре 2017. године, метода \code{\#populateDb}, a за оне касније \code{\#populateDb2017}. Како би се спречиле било какве друге акције током учитавања података, када је \code{Init\#INIT\_PHASE} постављен на \code{true}, дозвољено је само извршавање метода из \code{Init} класе. У супротном, када је  \code{Init\#INIT\_PHASE} \code{false}, није дозвољено извршавати метода за иницијализацију.

Учитавање података се обавља у неколико трансакција на бази. Позив \code{com.avaje\allowbreak.ebean\allowbreak.Ebean\allowbreak\#execute} означава једну трансакцију. Oва метода као аргумент прима \emph{ламбду}. Ламбда се може посматрати као анонимна метода. Унутар заграда се налазе параметри, ако постоје, затим следи \enquote{стрелица} (\code{->}), па једна наредба или тело методе. Ако је ламбда облика \code{(arg) -> Class.method(arg)}, она се може заменити референцом на методу облика \code{Class::method}. Овакве методе, које као аргументе могу примати ламбде, су еквивалент функцијама вишег реда из функционалног програмирања.

Узмимо као пример линију кода из \code{Init\#populateDb2017} методе: \code{Ebean.execute(() \allowbreak->\allowbreak svi\allowbreak.forEach\allowbreak(Ucenik2017::create));}, где је \code{svi} променљива типа \code{Set<UcenikW>}. Она извршава трансакцију у којој се над променљивом \code{svi} позива метода \code{forEach} која над сваким елементом извршава одређену операцију. \code{forEach} такође као аргумент прима ламбду, и њој се прослеђује референца на методу \code{Ucenik2017\#create}. Ово резултује у позивању методе \code{Ucenik2017\#create(UcenikW)} за сваки члан скупа \code{svi}, унутар једне трансакције на бази. У случају да дође до изузетка или грешке при извршавању, аутоматски се извршава \code{rollback} и база се враћа у првобитно стање. Сличан поступак се извршава и за сваки смер и основну школу, независно од генерације, и сви они имају одговарајућу статичку методу \code{create}.

Приметићемо да унутар сваког ентитета постоји доста сличних поља. Рецимо, за сваки предмет, називи поља су истог облика, и оцене из математике се чувају унутар поља \code{matematika6}, \code{matematika7} и \code{matematika8}, док је њихов просек смештен у \code{matematika\_p}. Ручно постављање ових поља би била прилично заморна и репетитивна радња, посебно када постоји јасан процедурални поступак за њихову иницијализацију. У случају генерације чији су подаци прикупљани 2017. године, метода која пребацује податке из облика у којем их библиотека чува у облик који се серијализује у базу се зове \code{models.Ucenik\allowbreak\#populateGrades2017}.

Скрепер чува податке о оценама у мапи која има текстуални кључ и целобројну вредност. Осим у пар изузетака, поље у ком вредност треба да се чува ће имати назив \code{\{кључ\}\{разред\}}, где је разред \code{6}, \code{7} или \code{8}. Механизам којим је могуће у току извршавања приступити неком пољу, методи или класи чије се име не мора знати унапред се назива \emph{рефлекција}. Почетна тачка је оно што знамо, а то је класа: знамо да се поља налазе у класи чија инстанца је прослеђена методи \code{Ucenik\#populateGrades2017}, и зовемо \code{\#getClass} над тим објектом како бисмо добили референцу на класу (објекат класе \code{Class}). Затим, над \code{Class} објектом извршавамо \code{\#getField(String)}, где је једини аргумент име поља, како бисмо добили референцу на поље. Коначно над пољем извршавамо \code{\#setInt(Object, int)} коме прослеђујемо \code{int} жељену вредност, и инстанцу чијем пољу ту вредност желимо да доделимо.

Овај механизам се користи и код рачунања просечних вредности и у ентитетима који се односе на ученике и у онима који се односе на школе и смерове. За последња два су задужене методе \code{Init\#populateSchoolAverages} и \code{Init\#populateAveragesInner}. Једина разлика је што не постоји мапа из које се извлаче вредности, већ се користи \code{Class\#getFields} како би се добио низ поља из којих се састоји основна школа/смер. За свако поље које је типа \code{double} (проверава се позивом \code{Field\#getType} и упоређивањем враћене вредности са \code{double.class}) и постоји поље истог имена типа \code{int} или \code{double} у класи ученик, рачуна се просек вредности поља сваког ученика који је похађао ту школу/уписао тај смер и уписује се у одговарајуће поље школе или смера.



\section{Пример употребе -- упити и базично плотовање}

Пример апликације која се може направити када постоји функционална база је приложен у Додатку \ref{ch:V}, као део изворног кода сервера. У питању је веб платформа која допушта кориснику на поставља упите серверу и на њих одговори или једним бројем или графиконом који на две или три осе представља дате податке. Већи кружићи на плоту означавају већи број ентитета са одређеним вредностима особина које су дате осама. 

Језик којим се постављају упити је инспирисан SQL-ом, користи српске речи, а преводи се у SQL који се на бази извршава. Превођење се извршава у класи \code{controllers.Parser}. Један упит се може превести у више SQL упита, а ако се они плотују постоји опција да њихови резултати буду различито обојени. Када се сервер покрене, подразумевано понашање је преусмеравање на путању \code{/query} која служи као почетна тачка за ову апликацију. 

Ова функционалност је дата као пример употребе сервера, и њен детаљан опис није у домену овог рада. Изворни код садржи README фајл са више информација, а тренутна верзија се може наћи и на \url{https://github.com/luq-0/UpisStats}. 

Овакав приступ је једноставнији за крајњег корисника и може да пружи лепу визуелизацију података, али није довољно робустан за било какву иоле озбиљнију анализу података. Начини на које се може приступити свим подацима без ограничења, и кроз скрепер и кроз базу, су изложени у следећем делу.
%\subsection{\textit{Dependency injection}} оставићемо ово за други пут