\chapter{Скрепер}\label{ch:\thechapter}

У основи овог пројекта се налази скрепер, који преузима све податке са сајта за упис. У овом раду се за навођење специфичних пакета, класи, интерфејса, метода или поља користи Javadoc стил, тј. као хијерархијски сепаратор пакета и класа се користи карактер \code{.}, док се пре методе или поља налази карактер \code{\#}. Сви називи су дословно узети и записани су користећи \code{monospace фонт}.



\section{Структура програма}
\vspace*{-7mm}
\emph{За изворни код који ће се овде коментарисати, видети додатак \ref{ch:V}.}

Комплетан програм је писан у програмском језику Java, верзија 8 и користи Gradle као \emph{build system} који изграђује пројекат, тј. проналази и преузима библиотеке, компајлира код и пакује све у .jar фајл који се може покренути на Java виртуелној машини. Аналогну улогу игра make у екосистему програмског језика C. За разлику од алата Ant и Maven који су нешто старији и чешће се срећу, посебно у старијим програмима и у курикулуму, Gradle је базиран на синтакси програмског језика Groovy уместо XML-а, што чини конфигурацијске фајлове краћим и лакшим за читање. Конфигурацијски фајл се по конвенцији назива \code{build.gradle} и налази се у кореном директоријуму пројекта. (Детаљан опис Gradle система је ван домена овог рада. За више информација, видети званичну документацију на \url{https://docs.gradle.org/current/userguide/userguide.html}.)

Код се налази унутар директоријума \code{src/main/java/} и корени пакет се зове \code{rs.lukaj\allowbreak.upisstats\allowbreak.scraper}, унутар кога је главна (main) класа \code{Main}. Програм прима један или више аргумената преко командне линије. Аргумент којим се врши преузимање је \code{dl} (од енглеског \textit{download}) и ово поглавље објашњава како тај процес тече. Друга могућа команда је \code{exec}, праћена методама за извршавање, која је детаљније описана у одељку 6.1 и има смисла само када су подаци већ преузети. Сав код који је релевантан за ову главу се налази у \code{download} пакету.



\section{Принцип рада и дељени код}

Већ је споменуто да се портал са кога се преузимају подаци значајно разликовао пре 2017. године у односу на садашњу варијанту. Међутим, принцип којим се до података долази је већим делом исти, што омогућава да је део кода дељен и користи се без обзира која се варијанта преузима. Као заједнички интерфејс се користи \code{DownloadConfig} и он представља спону између два начина за преузимање. Његове имплементације, \code{DownloadConfig.Old} и \code{DownloadConfig.New} пружају, редом, начине да се обави скреповање старог и новог портала.

\code{DownloadController} контролише процес преузимања, који тече на сличан начин као када бисмо ручно копирали све податке. Прво се преузимају шифре свих смерова и чувају у фајл \code{smerovi} који се налази унутар директоријума одређеног \code{File} објектом \code{DATA\_FOLDER}. Ако је преузимање раније започето, односно постоји \code{save} фајл, из њега се учитава индекс смера чије је преузимање прекинуто и оно започиње испочетка (како и највећи смерови броје мање од 300 ученика, количина посла која се понавља је занемарљива у односу на укупан обим). 

Други дељени део кода је \code{UceniciManager} који одржава редове шифара које треба преузети, преузетих ученика и неуспелих преузимања. У ред у којем се налазе шифре се додају нове у групама (користећи \code{UceniciManager\#add}), где свака група представља један образовни профил, тј. смер, до одређене границе. Када се граница прекорачи, све шифре се шаљу на преузимање (\code{UceniciManager\#download}), а затим се подаци чувају, за сваког ученика у засебан фајл (ово је прилично наивна и неефикасна шема за чување података за обраду, али је у тренутку писања деловала практично за потребе преузимања; касније ћемо видети на који начин се може унапредити). 

Чување се одвија у засебној нити користећи \code{ExecutorService} механизам из Java стандардне библиотеке који поједностављује рад са вишенитним (енгл. multithreaded) програмима, како се не би блокирао процес преузимања. Када се преузимање заврши, нит која је претходно попуњавала ред са шифрама непреузетих ученика се ослобађа и процес се наставља, све док постоје непреузети смерови (за овај део је заслужан \code{StudentDownloader\#download\allowbreak StudentData} који се такође користи независно од године преузимања).



\section{Стара варијанта -- пре 2017. године}

Стари сервер је био писан у програмском језику PHP и налазио се на адреси 195.222.98.59 (из неког разлога, сајт је увек правио конекције директно на IP адресу, уместо на домен, тако да и скрепер имитира то понашање). За сваку категорију података, било је неопходно слати нови захтев како би сервер вратио страницу са траженим информацијама. Тако се страница са листом смерова који се налазе у одређеном округу добија једним захтевом, оцене из шестог разреда конкретног ученика другим, оцене из седмог разреда трећим, итд. Конкретни параметри и адресе се могу добити посматрањем захтева које претраживач прави када се порталу ручно приступа, и затим у програму само треба поновити исте са измењеном шифром смера или ученика.

\code{StudentDownloader} је класа која служи за преузимање шифара ученика. Странице на старом порталу су биле организоване као више нивоа угњеждених табела (што је био популаран начин за дизајнирање сајтова деведесетих година прошлог века \citep{htmltables}), из којих овај програм треба да извуче податке. За парсирање HTML кода који се добија преузимањем користи се Jsoup библиотека која може да изгради DOM у меморији и врати корени чвор, \code{Document}. Свака ћелија у табели има јединствени секвенцијални \code{id}, и табела са шифрама има четири колоне, тако да знамо да се шифре налазе у ћелијама обележеним \code{id}-јевима 1, 5, 9, итд. а бројеви бодова у ћелијама 4, 8, 12, итд.

За потребе селектовања одређеног елемента, Jsoup подржава \emph{CSS селекторе}. Од синтаксних правила битних за овај пројекат, важно је знати да се \code{id}-јеви (\code{id} атрибут на HTML елементу) означавају почетном \code{\#}, класе (\code{class} атрибут) почетном тачком, а размак означава хијерархијско \enquote{испод}. Тако нпр. \code{\#id0 .class1 .class2} селектује све елементе класе \code{class2} који су деца елемената класе \code{class1}, који су деца елемента чији \code{id} атрибут има вредност \code{id0}. Ово је сасвим довољно да дођемо до произвољног елемента ако он има \code{id} (који је по дефиницији јединствен) или класе елемената кроз коју можемо проћи итерацијом и издвојити оне који нам требају.

Када знамо шифру ученика, конструишемо нову инстанцу класе \code{Ucenik} чијем конструктору прослеђујемо шифру, и позивамо методу \code{\#loadFromNet}. Круг уписа и укупан број бодова нису видљиви на страници ученика, тако да се они \enquote{убацују} користећи \code{\#setDetails} методу (укупан број бодова на страници ученика приказује само збир бодова добијених на основу оцена и пријемног испита, док је на страници смера на којој је листа ученика приказан стваран број, који рачуна и пријемни испит и афирмативне мере). \code{\#loadFromNet} учитава страницу ученика, странице за оцене из сваког разреда и листе жеља за оба круга, ако постоје, и из сваке табеле извлачи адекватне податке. \code{\#toCompactString} и \code{\#loadFromString} дефинишу формат у којем се \code{Ucenik} чува на диску, тј. начин на који се сва поља серијализују.

\code{Ucenik} садржи поља у којима се преузети подаци чувају, која су или текстуалног типа (\code{String}) или мапирају текстуални кључ у текстуалну вредност (\code{Map<String, String>}). Оваква флексибилност омогућава да поједине вредности недостају, да се на месту где се очекује бројчана вредност појави неки други карактер, или уопште да се било где појави било каква вредност. Иако можда звучи контраинтуитивно, ово је управо жељено понашање. У системима ове скале, чак и ако су савршено пројектовани и реализовани (што углавном није случај), није оправдано претпоставити било коју структуру података која аутору звучи логично, већ је много јефтиније прихватити све улазе при прикупљању, а верификацију претпоставки оставити за процес обраде података и све проблеме решавати \enquote{у ходу}. Података који недостају ће бити, а вредности ће се јављати чак и на местима где немају семантичког смисла, и нема потребе да то утиче на процес прикупљања који је коректно изведен. 

Преузимање комплетних података о основним школама  (односно, све сем имена, места и округа) је додато накнадно, у току 2016. године -- у првобитној верзији нисам сматрао то довољно битним, нити сам нашао иједан практичан начин да то преузимање изведем. Пошто за сваку генерацију постоји одређени временски прозор у којем су подаци доступни на порталу, није било могуће ретроактивно преузети податке. Класе које врше преузимање и дефинишу структуру података за основне школе се налазе у \code{.download.misc} пакету. Претпоставља се да су идентификациони бројеви за основне школе који се користе на серверу \emph{скоро секвенцијални}, тј. да је размак између два суседна мањи од 100. Међутим, чак и када се на овај начин преузму подаци, нисам нашао ниједан поуздан начин да се те исте основне школе повежу са ученицима који су их похађали, тако да је употребљивост овако добијених података ограничена.

У фокусу 2015. године када је ово писано су ми били они ученици који су уписали средњу школу у првом кругу, тако да се листе жеља за други круг не преузимају. Такође, подаци о кругу када је ученик уписан нису у потпуности прецизни -- не прави се разлика између оних који су уписали смер у другом кругу и оних који су уписани по одлуци окружне уписне комисије. Број уписаних ученика у другом кругу углавном износи око 1500, што чини нешто више од два процента података. (Сви наведени пропусти су исправљени у новијој варијанти, а \enquote{пролазност} података на порталу ми не допушта да измене и допуне направим ретроактивно. Управо овај временски оквир и компатибилност као приоритет су главни разлози зашто су неки неоптимални избори у вези са архитектуром и дизајном \enquote{преживели} у коду три године и тешко их је у овом тренутку променити.)

У току извршавања програма, само за преузимање података о ученицима, направи се преко 330 хиљада захтева (по шест за сваког ученика), док је за остале типове података овај број компаративно миноран: можемо проценити да укупан број захтева који долази до сервера износи око 350 хиљада. Просечно време извршавања износи око 30 сати, из чега се добија да се у просеку реализује нешто мање од 3.5 захтева по секунди. У сваком тренутку, отворена је највише једна конекција сервером. Све у свему, иако је процес обиман и дугачак, не може се рећи да на било који начин угрожава или омета рад сервера, пошто чак и серверски оквири којима брзина није први приоритет, попут Apache-а, могу без проблема услужити и за неколико редова величине веће оптерећење \citep{apacheperf}. Наравно, требало би избегавати покретање овог програма када се абнормално велика оптерећења сервера очекују, нпр. непосредно након објављивања података, како би се избегла чекања и захтеви који могу остати незадовољени услед преоптерећења и морају бити поновљени (опет наглашавам, овај програм, по дизајну, \emph{не може} значајно да оптерети сервер).



\section{Нова варијанта -- од 2017. године}

У неким класама, поједине методе се могу искористити и на новој верзији портала. Како би се избегло дуплицирање кода, користи се \emph{наслеђивање}. Класе које имају суфикс \code{2017} у имену, сем \code{OsnovneDownloader2017} и \code{Osnovna2017}, су поткласе класа истог имена без овог суфикса. Како би ово било могуће, када сам модификовао програм 2017. године, елиминисао сам већину статичких метода које није могуће наследити. Уместо њих, класе које их садрже су добиле заштићени (\code{protected}) подразумеван конструктор и статичку \code{getInstance} методу која је намењена за креирање једне инстанце при првом позиву, која се чува у приватном статичком пољу, и враћање сачуване инстанце при сваком следећем позиву (ово је директно инспирисано \emph{singleton} шаблоном).

У овом одељку бих се осврнуо само на то како су подаци организовани на новом порталу. Уместо унутар серије табела, подаци се учитавају користећи Javascript код, унутар кога су дефинисани сви подаци као варијабле. Како бисмо дошли до тих података, нема потребе да тај код извршавамо и чекамо шта ће се појавити на екрану -- довољно је да лоцирамо где се код налази и извучемо декларације променљивих, пошто постоји велики број библиотека које разумеју овакве декларације и могу их парсирати. (Технички, такве библиотеке су намењене парсирању JSON формата који је сличан, али није идентичан; међутим, већина библиотека не прави ову дистинкцију.) 

Конкретно за пример странице ученика, све променљиве су дефинисане на почетку трећег од позади \code{script} тага. Ово је много систематичније и поузданије од старе варијанте и јасно је одређено где се која информација налази. Такође, подаци су организовани тако да сваки образовни профил, основна школа, општина, округ, подручје рада и језик има свој интерни идентификациони број. Сви бројеви се преносе при сваком захтеву, што иако је траћење протока, чини посао програма нешто лакшим: пошто су сви подаци на свакој страници, довољно је копирати цео блок са једног места и користити га сваки пут када треба да од броја добијемо конкретну вредност. Ово нам омогућава да мапирање дефинишемо на једном месту, унутар класе \code{SmerMappingTools}.

Прва последица боље организованих података која се примећује је значајно мање времена утрошеног за процес преузимања. Пошто се сада за сваког ученика прави један уместо шест захтева, и притом су они појединачно бржи (да ли због боље архитектуре или јачег хардвера, могу само да нагађам), време преузимања је смањено 6-8 пута. 

Друга ствар, приметна тек при обради података, је чињеница да су нови подаци потпунији, прецизнији и смисленији. Тако сам, на пример, у старој верзији број бодова са пријемног дефинисао као разлику укупног броја бодова и збира бодова који је добијен на основу оцена, завршног испита и такмичења, што доводи до тога да постоје мале вредности које су резултат (не)заокруживања, или бодови који су заправо резултат афирмативне мере а не пријемног испита, или чак негативне вредности које се јављају у неким случајевима када је ученик уписан одлуком окружне уписне комисије и има заведен укупан број бодова као нула. У новој верзији, сасвим је јасно где се налази број бодова са пријемног испита на страници сваког ученика. На располагању је и више података: подаци о основним школама су систематично преузети и повезани са ученицима, за сваког ученика постоји јасно назначено на основу чега је добио који бод, па чак се и за сваку ставку на листи жеља види колико му се бодова рачуна, пошто ови бодови не морају да буду нужно исти, нпр. ако је полагао више пријемних испита са различитим успехом.

\vspace{5mm} %let's break this up a bit

Нова верзија скрепера, уз податке серијализоване у формату који описује \code{Ucenik2017\allowbreak\#toCompactString} метода, чува и оригиналне исечке Javascript кода из кога су оне добијени, за случај да буде неопходно употпунити податке, или верификовати неки податак без приступа оригиналном извору. Податке је могуће учитати фајл по фајл, користећи \code{Ucenik\#loadFromString} (и, аналогно, \code{Ucenik2017\#loadFromString}), али овај процес на класичним хард дисковима може да потраје много више времена него што је то неопходно. Начин како да се ово убрза је спајање свих фајлова у један, што је једна од првих ствари описаних у глави \ref{ch:6}, и препоручљиво је извршити је пре било какве обраде.



\section{Омотачи}

Раније је споменуто да се сви преузети подаци чувају у текстуалном формату и образложене су предности овог приступа. Није тешко уочити зашто је текстуални формат непрактичан за обраду, а његово парсирање сваки пут када желимо да дођемо до броја је непотребно скупо. За потребе обраде, дефинисани су \emph{омотачи}, објекти идентичне садржине али различитих типова података који ће се у остатку рада користити за манипулисање подацима.

Омотач за податке прикупљене користећи стару варијанту скрепера је дефинисан класом \code{rs.lukaj\allowbreak.upisstats\allowbreak.scraper\allowbreak.obrada\allowbreak.UcenikWrapper}, унутар које се налазе класе \code{Takmicenje} (чува податке о нивоу такмичења и освојеној награди), \code{OsnovnaSkola} (садржи податке о похађаној основној школи у којој је ученик завршио осми разред) и \code{SrednjaSkola} (састоји се од података о уписаном смеру). Сем конвертовања текстуалних података у нумеричке вредности и обрађивања случајева када неки податак не постоји, омотач рачуна и чини лако доступним просеке и тачне бројеве бодова за сваку категорију која се бодује (неки од ових података су додати и на сајт 2016. године).

Омотач за податке прикупљене 2017. године је дефинисан класом \code{rs\allowbreak.lukaj\allowbreak.upisstats\allowbreak.scraper\allowbreak.obrada2017\allowbreak.UcenikW}, и за разлику од \enquote{старијег брата}, не садржи поткласе које дефинишу податке о похађаној школи и уписаном смеру, већ су оне издвојене у \code{.obrada2017.OsnovnaW} и \code{.obrada2017.SmerW}. Ове класе такође у суштини \enquote{чисте} податке и рачунају корисне додатне вредности. Главни разлог овог разбијања је што у новој варијанти постоји више података за основне школе и смерове, док су оне оригинално биле само \enquote{успутне вредности} при прикупљању података за ученике.